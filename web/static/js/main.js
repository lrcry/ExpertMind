// Generated by CoffeeScript 1.10.0
(function() {
  angular.module('app', []).directive('modalAddNode', function() {
    return {
      restrict: 'A',
      templateUrl: 'static/partial/modal-add-node.html',
      controller: 'ModalAddNodeController'
    };
  }).directive('modalAddVote', function() {
    return {
      restrict: 'A',
      templateUrl: 'static/partial/modal-add-vote.html',
      controller: 'ModalAddVoteController'
    };
  }).directive('sidePanel', function() {
    return {
      restrict: 'A',
      templateUrl: 'static/partial/side-panel.html',
      controller: 'SidePanelController'
    };
  }).directive('mapCanvas', function() {
    return {
      restrict: 'A',
      templateUrl: 'static/partial/map-canvas.html',
      controller: 'MapCanvasController'
    };
  }).directive('eventNotificationList', function() {
    return {
      restrict: 'A',
      templateUrl: 'static/partial/event-notification-list.html',
      controller: 'EventNotificationController'
    };
  }).controller('RootController', ['$scope', '$http', function($scope, $http) {}]).controller('SidePanelController', [
    '$scope', '$http', function($scope, $http) {
      var $container;
      $container = $('.side-panel-container');
      $scope.$root.$on('selectNode', function(event, node) {
        $container.addClass('active');
        $scope.node = node;
        if (!$scope.$$phase) {
          return $scope.$apply();
        }
      });
      $scope.showAddVote = function() {
        return $scope.$emit('showAddVote', $scope.node, "1");
      };
      return $scope.close = function() {
        $container.removeClass('active');
        return void 0;
      };
    }
  ]).controller('EventNotificationController', [
    '$scope', '$http', function($scope, $http) {
      var getEventTitle;
      $scope.$root.$watch('mapData', function(mapData) {
        if (!mapData || !window.user) {
          return;
        }
        $scope.requesting_events = true;
        return $http.get("api/events?user_id=" + window.user.email + "&status=EVENT_UNREAD").then(function(response) {
          var event, i, len, ref, results;
          $scope.requesting_events = false;
          if (response.data.success === 'true') {
            $scope.events = response.data.data;
            ref = $scope.events;
            results = [];
            for (i = 0, len = ref.length; i < len; i++) {
              event = ref[i];
              results.push(event.title = getEventTitle(mapData, event));
            }
            return results;
          } else {
            return alert("[API Error] " + response.data.err_message);
          }
        }, function(response) {
          $scope.requesting_events = false;
          return alert('[Request Error]' + response.status);
        });
      });
      $scope.checkEvent = function(event) {
        $scope.events.splice($scope.events.indexOf(event), 1);
        event.status = 'EVENT_READ';
        return $http.put("api/events/" + event._id, event);
      };
      return getEventTitle = function(mapData, event) {
        var i, item, len, node, ref, time;
        node = {
          text: 'Unknown'
        };
        ref = mapData.node_list;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (item.id === event.node_id) {
            node = item;
            break;
          }
        }
        time = moment.duration(moment.utc(event.create_at).local().diff(moment())).humanize(true);
        switch (event.operation) {
          case 'CREATE_NEW_NODE':
            return event.user_id + " created a new node \"" + node.text + "\" " + time;
          case 'ADD_CHILD_NODE':
            return event.user_id + " added a child node to \"" + node.text + "\" " + time;
          case 'VOTE_UP':
            return event.user_id + " up-voted node \"" + node.text + "\" " + time;
          case 'VOTE_DOWN':
            return event.user_id + " down-voted node \"" + node.text + "\" " + time;
        }
      };
    }
  ]).controller('ModalAddVoteController', [
    '$scope', '$http', function($scope, $http) {
      var $modal;
      $modal = $('.modal-add-vote');
      $scope.submit_vote = function() {
        var userId;
        if (!$scope.comment || $scope.comment.length <= 0) {
          alert('Please leave a comment!');
          return;
        }
        $scope.requesting = true;
        userId = '';
        if (window.user) {
          userId = window.user.email;
        }
        return $http.post('api/votes', {
          userId: userId,
          type: $scope.vote,
          comment: $scope.comment,
          nodeId: $scope.node.id
        }).then(function(response) {
          $scope.requesting = false;
          if (response.data.success === 'true') {
            $modal.modal('hide');
            return $scope.$emit('updateNodeVotes', $scope.node);
          } else {
            return alert("[API Error] " + response.data.error_message);
          }
        }, function(response) {
          $scope.requesting = false;
          return alert('[Request Error]' + response.status);
        });
      };
      return $scope.$root.$on('showAddVote', function(event, node, vote) {
        $scope.node = node;
        $scope.vote = vote;
        if (!$scope.$$phase) {
          $scope.$apply();
        }
        return $modal.modal('show');
      });
    }
  ]).controller('ModalAddNodeController', [
    '$scope', '$http', function($scope, $http) {
      var $modal;
      $modal = $('.modal-add-node');
      $scope.newNode = {
        parent: null,
        title: "",
        description: ""
      };
      $scope.submit = function() {
        var entity, node, userId;
        node = $scope.newNode;
        if (node.title.length <= 0) {
          alert('Please input title!');
          return;
        }
        if (node.description.length <= 0) {
          alert('Please input description!');
          return;
        }
        userId = '';
        if (window.user) {
          userId = window.user.email;
        }
        entity = {
          nodeDisplay: node.title,
          nodeDescription: node.description,
          userId: userId
        };
        if (node.parent !== null) {
          entity.nodeParents = [
            {
              _id: node.parent.id
            }
          ];
        }
        $scope.requesting = true;
        return $http.post('api/nodes', entity).then(function(response) {
          if (response.data.success === 'true') {
            $scope.requesting = false;
            return window.location.reload();
          } else {
            alert("[API Error] " + response.data.error_message);
            return $scope.requesting = false;
          }
        }, function(response) {
          alert('[Request Error]' + response.status);
          return $scope.requesting = false;
        });
      };
      return $scope.$root.$on('showAddNode', function(event, node) {
        $scope.newNode.parent = node;
        if (!$scope.$$phase) {
          $scope.$apply();
        }
        return $modal.modal('show');
      });
    }
  ]).controller('MapCanvasController', [
    '$scope', '$http', function($scope, $http) {
      var init, pre_process, render, summarize_and_optimize_votes;
      init = function() {
        var SCALE_MAX, SCALE_MIN, stage;
        SCALE_MIN = 0.2;
        SCALE_MAX = 2.0;
        stage = new Konva.Stage({
          container: 'map_container',
          width: window.innerWidth,
          height: window.innerHeight
        });
        $scope.loading = true;
        $http.get('api/nodes').then(function(response) {
          var mapData;
          $scope.loading = false;
          mapData = pre_process(response.data);
          if (!!mapData) {
            render(stage, null, mapData);
            $scope.$root.mapData = mapData;
          }
          return $scope.$root.loaded = true;
        }, function(response) {
          alert('[Request Error]' + response.status);
          return $scope.loading = false;
        });
        return $(window).on('resize orientationchange', function() {
          stage.setWidth(window.innerWidth);
          return stage.setHeight(window.innerHeight);
        }).on('mousewheel', function(e) {
          var mouse, newScale, offset, scale;
          offset = stage.offset();
          mouse = stage.getPointerPosition();
          if (!mouse) {
            return;
          }
          scale = stage.scale().x;
          newScale = scale + e.originalEvent.wheelDelta / 2000.0;
          newScale = Math.max(SCALE_MIN, Math.min(SCALE_MAX, newScale));
          stage.scale({
            x: newScale,
            y: newScale
          });
          stage.offset({
            x: offset.x + (mouse.x - offset.x) * (1 - scale / newScale),
            y: offset.y + (mouse.y - offset.y) * (1 - scale / newScale)
          });
          return stage.draw();
        }).on('keydown', function(e) {
          switch (e.keyCode) {
            case 37:
              stage.offsetX(stage.offsetX() + 10);
              break;
            case 38:
              stage.offsetY(stage.offsetY() + 10);
              break;
            case 39:
              stage.offsetX(stage.offsetX() - 10);
              break;
            case 40:
              stage.offsetY(stage.offsetY() - 10);
          }
          return stage.draw();
        });
      };
      pre_process = function(data) {
        var author, i, item, len, ref, ret, votes;
        if (data.success !== 'true') {
          alert("[API Error] " + data.error_message);
          return false;
        }
        ret = {
          root_node_id: null,
          node_list: []
        };
        ref = data.data;
        for (i = 0, len = ref.length; i < len; i++) {
          item = ref[i];
          if (item.nodeParents.length <= 0) {
            if (ret.root_node_id === null) {
              ret.root_node_id = item._id;
            } else {
              console.warn('Multiple root node detected, only the first one will be used.');
            }
          }
          votes = summarize_and_optimize_votes(item.nodeVotes);
          author = {
            id: '',
            name: "Anonymous"
          };
          if (!!item.userId && item.userId !== '') {
            author.id = author.name = item.userId;
          }
          ret.node_list.push({
            id: item._id,
            text: item.nodeDisplay,
            author: author,
            description: item.nodeDescription,
            creation_time: item.nodeCreateAt,
            up_vote: votes.up,
            down_vote: votes.down,
            vote_list: item.nodeVotes,
            sub_nodes: $.map(item.nodeChildren, function(obj) {
              return obj._id;
            })
          });
        }
        return ret;
      };
      summarize_and_optimize_votes = function(voteList) {
        var downVoteCount, i, j, len, len1, ret, upVoteCount, vote;
        for (i = 0, len = voteList.length; i < len; i++) {
          vote = voteList[i];
          vote.voteDate = moment.utc(vote.voteDate).local().format('YYYY/MM/DD HH:mm');
        }
        upVoteCount = 0;
        downVoteCount = 0;
        for (j = 0, len1 = voteList.length; j < len1; j++) {
          vote = voteList[j];
          if (vote.type === "1") {
            upVoteCount++;
          } else if (vote.type === "-1") {
            downVoteCount++;
          }
        }
        ret = {
          up: upVoteCount,
          down: downVoteCount
        };
        return ret;
      };
      render = function(stage, userData, mapData) {
        var ADD_BTN_SIZE, INFO_TEXT_SIZE, NODE_WIDTH, TITLE_TEXT_SIZE, active_node, buildAddRootBtn, buildLinks, buildNode, centeringNode, computeLinkPoints, drag_anchor, getNode, hideNodeTree, i, layer, layout, layoutLevel, len, map_nodes, moveSubNodes, node, nodeGroup, nodeId, ref, rootNode, setupAnchor, toggleAddNodeBtn, toggleNode, updateParentLinks;
        NODE_WIDTH = 200;
        TITLE_TEXT_SIZE = 18;
        INFO_TEXT_SIZE = 12;
        ADD_BTN_SIZE = 40;
        layer = new Konva.Layer();
        map_nodes = {};
        active_node = null;
        drag_anchor = {};
        getNode = function(id) {
          return layer.findOne('#node-' + id);
        };
        hideNodeTree = function(rootNode) {
          var bg, i, j, len, len1, ref, subNodeId, subNodes;
          subNodes = map_nodes[rootNode.getId()].sub_nodes;
          for (i = 0, len = subNodes.length; i < len; i++) {
            subNodeId = subNodes[i];
            hideNodeTree(getNode(subNodeId));
          }
          if (subNodes.length > 0) {
            ref = rootNode.find('.node-collapsed-bg');
            for (j = 0, len1 = ref.length; j < len1; j++) {
              bg = ref[j];
              bg.show();
            }
          }
          rootNode.hide();
          return layer.findOne(".to-" + (rootNode.getId())).hide();
        };
        toggleNode = function(node) {
          var bg, collapsed, i, j, len, len1, nodeObj, ref, ref1, subNode, subNodeId;
          nodeObj = map_nodes[node.getId()];
          collapsed = false;
          ref = nodeObj.sub_nodes;
          for (i = 0, len = ref.length; i < len; i++) {
            subNodeId = ref[i];
            subNode = getNode(subNodeId);
            if (!subNode.isVisible()) {
              subNode.show();
              layer.findOne(".to-" + (subNode.getId())).show();
            } else {
              collapsed = true;
              hideNodeTree(subNode);
            }
          }
          if (collapsed) {
            node.addName('collapsed');
          } else {
            node.removeName('collapsed');
          }
          if (nodeObj.sub_nodes.length > 0) {
            ref1 = node.find('.node-collapsed-bg');
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              bg = ref1[j];
              if (collapsed) {
                bg.show();
              } else {
                bg.hide();
              }
            }
          }
          return updateParentLinks(node);
        };
        setupAnchor = function(node, onClick) {
          return node.on('mouseover', function() {
            return document.body.style.cursor = 'pointer';
          }).on('mouseout', function() {
            return document.body.style.cursor = 'default';
          }).on('click tap', function(evt) {
            if (onClick) {
              onClick.call(this, evt);
              evt.evt.stopPropagation();
              return evt.evt.preventDefault();
            }
          });
        };
        buildNode = function(node) {
          var infoBarHeight, nodeAddChildGroup, nodeAddChildShape, nodeAddChildText, nodeAuthorText, nodeDownVoteBtn, nodeGroup, nodeInfoBar, nodeInfoBarRect, nodeRect, nodeRect2, nodeRect3, nodeText, nodeUpVoteBtn, nodeVoteBtnGroup, voteBtnGroupWidth;
          nodeText = new Konva.Text({
            text: node.text,
            fontSize: TITLE_TEXT_SIZE,
            fontFamily: 'Calibri',
            fill: '#555',
            width: NODE_WIDTH,
            padding: 20,
            align: 'center'
          });
          nodeUpVoteBtn = new Konva.Text({
            text: "+" + node.up_vote,
            fontSize: INFO_TEXT_SIZE,
            fontFamily: 'Calibri',
            name: "btn-up-vote",
            fill: '#555',
            padding: 9
          });
          nodeDownVoteBtn = new Konva.Text({
            text: "-" + node.down_vote,
            fontSize: INFO_TEXT_SIZE,
            fontFamily: 'Calibri',
            name: "btn-down-vote",
            fill: '#555',
            padding: 9,
            x: nodeUpVoteBtn.getWidth()
          });
          setupAnchor(nodeUpVoteBtn, function() {
            return $scope.$emit('showAddVote', node, "1");
          });
          setupAnchor(nodeDownVoteBtn, function() {
            return $scope.$emit('showAddVote', node, "-1");
          });
          nodeAuthorText = new Konva.Text({
            text: "by " + node.author.name,
            fontSize: INFO_TEXT_SIZE,
            fontFamily: 'Calibri',
            fill: '#555',
            width: NODE_WIDTH,
            padding: 9,
            align: 'left'
          });
          voteBtnGroupWidth = nodeUpVoteBtn.getWidth() + nodeDownVoteBtn.getWidth();
          nodeVoteBtnGroup = new Konva.Group({
            height: Math.max(nodeUpVoteBtn.getHeight(), nodeDownVoteBtn.getHeight()),
            width: voteBtnGroupWidth,
            x: NODE_WIDTH - voteBtnGroupWidth
          });
          nodeVoteBtnGroup.add(nodeUpVoteBtn);
          nodeVoteBtnGroup.add(nodeDownVoteBtn);
          infoBarHeight = Math.max(nodeVoteBtnGroup.getHeight(), nodeAuthorText.getHeight());
          nodeInfoBar = new Konva.Group({
            width: NODE_WIDTH,
            height: infoBarHeight,
            y: nodeText.getHeight()
          });
          nodeInfoBarRect = new Konva.Rect({
            width: NODE_WIDTH - 5,
            x: 2.5,
            height: infoBarHeight - 2,
            fill: "#bbb",
            cornerRadius: 10
          });
          nodeInfoBar.add(nodeInfoBarRect);
          nodeInfoBar.add(nodeAuthorText);
          nodeInfoBar.add(nodeVoteBtnGroup);
          nodeRect = new Konva.Rect({
            name: "node-bg",
            stroke: '#555',
            strokeWidth: 5,
            fill: '#ddd',
            width: NODE_WIDTH,
            height: nodeText.getHeight() + infoBarHeight,
            shadowColor: 'black',
            shadowBlur: 10,
            shadowOffset: [10, 10],
            shadowOpacity: 0.2,
            cornerRadius: 10
          });
          nodeAddChildShape = new Konva.Wedge({
            stroke: '#375A7F',
            strokeWidth: 5,
            fill: '#ddd',
            radius: ADD_BTN_SIZE / 2.0,
            angle: 180
          });
          nodeAddChildText = new Konva.Text({
            text: '+',
            fontSize: 32,
            fontStyle: 'bold',
            fontFamily: 'Calibri',
            fill: '#375A7F',
            width: ADD_BTN_SIZE,
            x: -ADD_BTN_SIZE / 2.0,
            y: -ADD_BTN_SIZE / 2.0 + 10,
            align: 'center'
          });
          nodeAddChildGroup = new Konva.Group({
            name: 'add-child',
            width: ADD_BTN_SIZE,
            height: ADD_BTN_SIZE,
            x: NODE_WIDTH / 2.0,
            y: nodeRect.height() - ADD_BTN_SIZE / 2.0
          });
          nodeAddChildGroup.add(nodeAddChildShape);
          nodeAddChildGroup.add(nodeAddChildText);
          setupAnchor(nodeAddChildGroup, function() {
            return $scope.$emit('showAddNode', node);
          });
          nodeGroup = new Konva.Group({
            width: nodeRect.width(),
            height: nodeRect.height(),
            draggable: true,
            visible: false
          });
          if (node.sub_nodes.length > 0) {
            nodeRect2 = new Konva.Rect({
              x: 10,
              y: 10,
              name: "node-bg node-collapsed-bg",
              stroke: '#555',
              strokeWidth: 5,
              fill: '#ddd',
              width: NODE_WIDTH,
              height: nodeText.getHeight() + infoBarHeight,
              shadowColor: 'black',
              shadowBlur: 10,
              shadowOffset: [10, 10],
              shadowOpacity: 0.2,
              cornerRadius: 10
            });
            nodeRect3 = new Konva.Rect({
              x: 20,
              y: 20,
              name: "node-bg node-collapsed-bg",
              stroke: '#555',
              strokeWidth: 5,
              fill: '#ddd',
              width: NODE_WIDTH,
              height: nodeText.getHeight() + infoBarHeight,
              shadowColor: 'black',
              shadowBlur: 10,
              shadowOffset: [10, 10],
              shadowOpacity: 0.2,
              cornerRadius: 10
            });
            nodeGroup.add(nodeRect3);
            nodeGroup.add(nodeRect2);
          }
          nodeGroup.add(nodeAddChildGroup);
          nodeGroup.add(nodeRect);
          nodeGroup.add(nodeText);
          nodeGroup.add(nodeInfoBar);
          nodeGroup.addName('node');
          if (node.sub_nodes.length > 0) {
            nodeGroup.addName('collapsed');
          }
          return nodeGroup;
        };
        buildAddRootBtn = function() {
          var nodeAddChildGroup, nodeAddChildShape, nodeAddChildText;
          nodeAddChildShape = new Konva.Circle({
            stroke: '#375A7F',
            strokeWidth: 5,
            fill: '#ddd',
            radius: ADD_BTN_SIZE / 2.0
          });
          nodeAddChildText = new Konva.Text({
            text: '+',
            fontSize: 48,
            fontStyle: 'bold',
            fontFamily: 'Calibri',
            fill: '#375A7F',
            width: ADD_BTN_SIZE,
            x: -ADD_BTN_SIZE / 2.0,
            y: -ADD_BTN_SIZE / 2.0 - 5,
            align: 'center'
          });
          nodeAddChildGroup = new Konva.Group({
            width: ADD_BTN_SIZE,
            height: ADD_BTN_SIZE,
            x: (stage.getWidth() - ADD_BTN_SIZE) / 2,
            y: (stage.getHeight() - ADD_BTN_SIZE) / 2
          });
          nodeAddChildGroup.add(nodeAddChildShape);
          nodeAddChildGroup.add(nodeAddChildText);
          return setupAnchor(nodeAddChildGroup, function() {
            return $scope.$emit('showAddNode', null);
          });
        };
        layoutLevel = function(level, angleStart, parentNodes) {
          var angle, angleStep, base_offset_x, childNodes, first_angle, i, ind, j, k, len, len1, len2, parentNode, ref, spaceCount, spaceStart, subNode, subNodeCount, subNodeId;
          spaceCount = 0;
          if (parentNodes.length > 1) {
            spaceCount = parentNodes.length;
          }
          spaceStart = 0;
          for (ind = i = 0, len = parentNodes.length; i < len; ind = ++i) {
            parentNode = parentNodes[ind];
            subNodeCount = map_nodes[parentNode.getId()].sub_nodes.length;
            spaceCount += subNodeCount;
            if (ind === 0 && subNodeCount > 0) {
              spaceStart = -(subNodeCount - 1) / 2.0;
            }
          }
          angleStep = 2 * Math.PI / spaceCount;
          angle = angleStart + spaceStart * angleStep;
          base_offset_x = (stage.getWidth() - NODE_WIDTH) / 2;
          childNodes = [];
          first_angle = 0;
          for (j = 0, len1 = parentNodes.length; j < len1; j++) {
            parentNode = parentNodes[j];
            ref = map_nodes[parentNode.getId()].sub_nodes;
            for (k = 0, len2 = ref.length; k < len2; k++) {
              subNodeId = ref[k];
              subNode = getNode(subNodeId);
              subNode.setPosition({
                x: base_offset_x + Math.cos(angle) * NODE_WIDTH * level * 1.6,
                y: (stage.getHeight() - subNode.getHeight()) / 2 + Math.sin(angle) * NODE_WIDTH * level * 1.0
              });
              childNodes.push(subNode);
              if (childNodes.length === 1) {
                first_angle = angle;
              }
              angle += angleStep;
            }
            angle += angleStep;
          }
          if (childNodes.length > 0) {
            return layoutLevel(level + 1, first_angle, childNodes);
          }
        };
        layout = function(rootNode) {
          rootNode.show();
          rootNode.setPosition({
            x: (stage.getWidth() - NODE_WIDTH) / 2,
            y: (stage.getHeight() - rootNode.getHeight()) / 2
          });
          return layoutLevel(1, -Math.PI / 2, [rootNode]);
        };
        computeLinkPoints = function(startNode, endNode) {
          var h1, h2, margin, w1, w2, x1, x2, y1, y2;
          x1 = startNode.x();
          y1 = startNode.y();
          w1 = startNode.width();
          h1 = startNode.height();
          x2 = endNode.x();
          y2 = endNode.y();
          w2 = endNode.width();
          h2 = endNode.height();
          margin = {
            top: 5,
            bottom: 5,
            left: 5,
            right: 5
          };
          if (endNode.hasName('collapsed')) {
            margin.bottom = margin.right = 25;
          }
          if (x1 > x2 + w2 + margin.right) {
            return [x1, y1 + h1 / 2.0, x2 + w2 + margin.right, y2 + h2 / 2.0];
          }
          if (x1 + w1 < x2 - margin.left) {
            return [x1 + w1, y1 + h1 / 2.0, x2 - margin.left, y2 + h2 / 2.0];
          }
          if (y1 > y2 + h2 + margin.bottom) {
            return [x1 + w1 / 2.0, y1, x2 + w2 / 2.0, y2 + h2 + margin.bottom];
          }
          if (y1 + h1 < y2 - margin.top) {
            return [x1 + w1 / 2.0, y1 + h1, x2 + w2 / 2.0, y2 - margin.top];
          }
          return [x1 + w1 / 2.0, y1 + h1 / 2.0, x1 + w1 / 2.0, y1 + h1 / 2.0];
        };
        buildLinks = function(parentNode) {
          var i, len, link, points, ref, results, subNode, subNodeId;
          ref = map_nodes[parentNode.getId()].sub_nodes;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            subNodeId = ref[i];
            subNode = getNode(subNodeId);
            points = computeLinkPoints(parentNode, subNode);
            link = new Konva.Arrow({
              name: "from-" + (parentNode.getId()) + " to-" + (subNode.getId()),
              points: points,
              pointerLength: 12,
              pointerWidth: 12,
              fill: 'black',
              stroke: 'black',
              strokeWidth: 4,
              visible: false
            });
            layer.add(link);
            results.push(buildLinks(subNode));
          }
          return results;
        };
        moveSubNodes = function(parentNode, move) {
          var anchor, endPoint, i, j, len, len1, link, name, ref, ref1, results, targetId;
          targetId = parentNode.getId();
          ref = layer.find(".from-" + targetId);
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            link = ref[i];
            endPoint = null;
            ref1 = link.name().split(' ');
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              name = ref1[j];
              if (name.indexOf('to-') === 0) {
                endPoint = layer.findOne("#" + name.substr(3));
                break;
              }
            }
            if (endPoint !== null) {
              anchor = drag_anchor[endPoint.getId()];
              endPoint.position({
                x: anchor.x + move.x,
                y: anchor.y + move.y
              });
              moveSubNodes(endPoint, move);
              results.push(link.points(computeLinkPoints(parentNode, endPoint)));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
        updateParentLinks = function(node) {
          var i, j, len, len1, link, name, ref, ref1, results, startPoint;
          ref = layer.find(".to-" + (node.getId()));
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            link = ref[i];
            startPoint = null;
            ref1 = link.name().split(' ');
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              name = ref1[j];
              if (name.indexOf('from-') === 0) {
                startPoint = layer.findOne("#" + name.substr(5));
                break;
              }
            }
            if (startPoint !== null) {
              results.push(link.points(computeLinkPoints(startPoint, node)));
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
        toggleAddNodeBtn = function(node, show) {
          var height;
          height = node.height();
          if (!show) {
            height -= ADD_BTN_SIZE / 2.0;
          }
          return new Konva.Tween({
            node: node.findOne('.add-child'),
            duration: 0.2,
            easing: Konva.Easings.EaseInOut,
            y: height
          }).play();
        };
        centeringNode = function(node) {
          var offsetX, offsetY, pos, scale;
          pos = node.position();
          scale = stage.scale();
          offsetX = (pos.x + node.width() / 2.0) - stage.width() / 2.0 / scale.x;
          offsetY = (pos.y + node.height() / 2.0) - stage.height() / 2.0 / scale.y;
          return new Konva.Tween({
            node: stage,
            duration: 0.2,
            easing: Konva.Easings.EaseInOut,
            offsetX: offsetX,
            offsetY: offsetY
          }).play();
        };
        ref = mapData.node_list;
        for (i = 0, len = ref.length; i < len; i++) {
          node = ref[i];
          nodeId = "node-" + node.id;
          map_nodes[nodeId] = node;
          nodeGroup = buildNode(node);
          nodeGroup.setId(nodeId);
          nodeGroup.on('click tap', function() {
            var bg, j, k, len1, len2, ref1, ref2;
            this.moveToTop();
            if (active_node === null || active_node !== this) {
              ref1 = this.find('.node-bg');
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                bg = ref1[j];
                bg.stroke('#375A7F');
              }
            }
            if (active_node !== null && active_node !== this) {
              ref2 = active_node.find('.node-bg');
              for (k = 0, len2 = ref2.length; k < len2; k++) {
                bg = ref2[k];
                bg.stroke('#555');
              }
              toggleAddNodeBtn(active_node, false);
            }
            active_node = this;
            toggleAddNodeBtn(this, true);
            $scope.$emit('selectNode', map_nodes[this.id()]);
            node = this;
            setTimeout(function() {
              return centeringNode(node);
            }, 300);
            return stage.draw();
          }).on('dragstart', function(e) {
            var j, len1, ref1, results;
            ref1 = layer.find(".node");
            results = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              node = ref1[j];
              results.push(drag_anchor[node.getId()] = node.position());
            }
            return results;
          }).on('dragmove', function(e) {
            var anchor, move, pos, targetId;
            targetId = this.getId();
            anchor = drag_anchor[targetId];
            pos = this.position();
            move = {
              x: pos.x - anchor.x,
              y: pos.y - anchor.y
            };
            moveSubNodes(this, move);
            return updateParentLinks(this);
          }).on('dblclick dbltap', function() {
            toggleNode(this);
            return stage.draw();
          });
          layer.add(nodeGroup);
        }
        rootNode = getNode(mapData.root_node_id);
        if (rootNode) {
          layout(rootNode);
          buildLinks(rootNode);
        } else {
          layer.add(buildAddRootBtn());
          $scope.$emit('showAddNode', null);
        }
        stage.add(layer);
        return $scope.$root.$on('updateNodeVotes', function(event, node) {
          $.blockUI({
            css: {
              border: 'none',
              padding: '15px',
              backgroundColor: '#000',
              '-webkit-border-radius': '10px',
              '-moz-border-radius': '10px',
              opacity: .5,
              color: '#fff'
            }
          });
          return $http.get("api/nodes/" + node.id).then(function(response) {
            var dataObj, votes;
            $.unblockUI();
            if (response.data.success === 'true') {
              dataObj = map_nodes["node-" + node.id];
              dataObj.vote_list = response.data.data.nodeVotes;
              votes = summarize_and_optimize_votes(dataObj.vote_list);
              dataObj.down_vote = votes.down;
              dataObj.up_vote = votes.up;
              nodeGroup = getNode(node.id);
              nodeGroup.findOne('.btn-up-vote').text("+" + votes.up);
              nodeGroup.findOne('.btn-down-vote').text("-" + votes.down);
              return stage.draw();
            } else {
              return alert("[API Error] " + response.data.error_message);
            }
          }, function(response) {
            $.unblockUI();
            return alert('[Request Error]' + response.status);
          });
        });
      };
      return init();
    }
  ]);

}).call(this);

//# sourceMappingURL=main.js.map
